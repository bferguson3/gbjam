INCLUDE "hardware.inc"
;INCLUDE "ibmpc1.inc"
INCLUDE "memory1.asm"
INCLUDE "header.z80"

; Music player vars
Player_Initialize       equ     $4000
Player_MusicStart       equ     $4003
Player_MusicStop        equ     $4006
Player_SongSelect       equ     $400c
Player_MusicUpdate      equ     $4100
MusicBank               equ     1
SongNumber              equ     0       ; 0 - 7
; Sprite Variables
Sprite_0_Y      EQU _OAMRAM
Sprite_0_X      EQU _OAMRAM+1
Sprite_0_Num    EQU _OAMRAM+2
Sprite_0_Att    EQU _OAMRAM+3
playerSprite1_y      equ _OAMRAM+4
playerSprite1_x      equ _OAMRAM+5
playerSprite1        equ _OAMRAM+6
playerSprite1Attr    equ _OAMRAM+7
playerSprite2_y      equ _OAMRAM+8
playerSprite2_x      equ _OAMRAM+9
playerSprite2        equ _OAMRAM+10
playerSprite2Attr    equ _OAMRAM+11
playerSprite3_y      equ _OAMRAM+12
playerSprite3_x      equ _OAMRAM+13
playerSprite3        equ _OAMRAM+14
playerSprite3Attr    equ _OAMRAM+15
playerSprite4_y      equ _OAMRAM+16
playerSprite4_x      equ _OAMRAM+17
playerSprite4        equ _OAMRAM+18
playerSprite4Attr    equ _OAMRAM+19
enemySprite1_y       equ _OAMRAM+20 ; (+4*4) for next 2x2 sprite
enemySprite2_y       equ _OAMRAM+36
; 6 = +24, 7 = +28; 8 = +32; 9 = +36; 10 = +40
MoveX   equ     _RAM      ; $c000
MoveY   equ     _RAM+1    ; + or -1 depends on border bounced
joypadReg       equ _RAM+2
fireDelay   equ     _RAM+3
playerBulletsOn equ _RAM+4

SECTION "main code", ROM0[$0150]
; Assembler input:
MAINCODESTART:
; $0150: Code!

start:
    nop
    di
    ld sp, $ffff
    ;jp initialize

initialize:
    ; set 4-color plaette
    ;ld a, %11 10 01 00 ; 3=w 2=dg 1=lg 0=blk
    ld a, %00100111 
    ld [rBGP], a
    ld [rOBP1], a
    ; for sprite, this makes black (color 0) transparent
    ld a, %11100100  ; invert transparency
    ld [rOBP0],a ; sprite palette same
    ; viewport to 0,0
    ld a, 0
    ld [rSCX], a
    ld [rSCY], a

    call LCD_Off    ; disable LCD to write to _VRAM
    ; copy tileset to vram
    ld hl, TileChar
    ld de, _VRAM
    ld bc, EndTileChar-TileChar           ;16 bytes per 1 char, 2 chars.
    call mem_Copy
    
    ; blank screen 32x32 with blank
    ld	a, 0		
	ld	hl, _SCRN0  ; load blank space into _SCRN0 ($9800)
	ld	bc, SCRN_VX_B * SCRN_VY_B ; 32 * 32 x tiles by y tiles
	call	mem_SetVRAM

    call DrawCloudTest
    ; draw cloud test routine - copy to 9800, bgmap data 1
    
    ; set vars
    ld a, 5
    ld [fireDelay], a
    ld a, 0
    ld [playerBulletsOn], a
    
    ; %x0000000 = priority, 1 = front window 0 = behind win, front bg
    ; %0x000000 = y flip
    ; %00x00000 = x flip
    ; %000x0000 = palette number
    ; %0000xxxx = unused
    ld a,30
    ld [Sprite_0_Y],a
    ld a,120
    ld [Sprite_0_X],a
    ld a,1
    ld [Sprite_0_Num],a
    ld a, 0
    ld [Sprite_0_Att],a
    
    ; Player sprite init
    ld a,50
    ld [playerSprite1_y], a
    ld [playerSprite1_x], a
    ld [playerSprite2_y], a
    ld [playerSprite3_x], a
    ld a,58
    ld [playerSprite2_x], a
    ld [playerSprite3_y], a
    ld [playerSprite4_x], a
    ld [playerSprite4_y], a
    ld a, 8
    ld [playerSprite1], a
    ld a, 9
    ld [playerSprite2], a
    ld a, 8+16
    ld [playerSprite3], a
    ld a, 9+16
    ld [playerSprite4], a
    ld a, 0 
    ld [playerSprite1Attr], a
    ld [playerSprite2Attr], a
    ld [playerSprite3Attr], a
    ld [playerSprite4Attr], a  

    ; enemy test
    ld a, 1 
    ld b, 1     ; enemy type: squid
    ld c, 150   ; x pos  (c, d) (c+8, d) 0 1  4, 5
    ld d, 30    ; y pos  (c, d+8) (c+8, d+8) 8,9 12,13
    call SpawnEnemy_ABCD
    
    ; turn back on LCD
    ;ld a, LCDCF_ON|LCDCF_BG8800|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8|LCDCF_OBJON
    ; LCD on, window @9800, window off, bgtiles @8800, bg #1, 8x8, solidwinclr, BG on
    ld a, %11000011
    ld [rLCDC], a

    ld a,1
    ld [MoveX],a
    ld [MoveY],a

    ; initialize music
FirstTime:
        ld      a,MusicBank             ; Switch to MusicBank
        ld      [rROMB0],a
        call    Player_Initialize       ; Initialize sound registers and
                                        ; player variables on startup
NewSong:
        ld      a,MusicBank             ; Switch to MusicBank
        ld      [rROMB0],a
        call    Player_MusicStart       ; Start music playing
        ld      a,SongNumber            ; Call SongSelect AFTER MusicStart!
        call    Player_SongSelect       ; (Not needed if SongNumber = 0)
    ; default loop:
FrameLoop:
        ld      c,$10                   ; Waiting
        call    WaitLCDLine
        ld      a,MusicBank             ; Switch to MusicBank
        ld      [rROMB0],a
        call    Player_MusicUpdate      ; Call this once a frame
        ; Non-VBlank Code:
        ;
        ; FireDelay dec code
        ld a, [fireDelay]
        cp a,0 
        jr z, .skipfd
        dec a
        ld [fireDelay], a
.skipfd:

        call    readJoypad
        ;
        ld      c,$90                   ; Wait for VBlank
        call    WaitLCDLine
        ; VBlank draw code:
        ;
        ; Update bullet positions
        ld a, [rSCX] 
        inc a 
        inc a 
        inc a 
        ld [rSCX], a 
        ld a, [rSCY]
        inc a 
        ld [rSCY], a 

firstBulletX        equ     _OAMRAM+(4*21)+1
        ld hl, firstBulletX
        ld a, [hl]
        add a, 4
        cp a,200                ; a-200
        jr nc, .destr_bullet    ; if no carry, destr bulet
        ld [hl], a
        jr .end_bullet
.destr_bullet:      ; sets pos to 0,0
        ld a, 0
        ld [hl], a
        dec hl
        ld [hl], a
.end_bullet:

        ld hl, firstBulletX+4
        ld a, [hl] 
        add a, 4 
        cp a, 200 
        jr nc, .destr_bullet2 
        ld [hl], a 
        jr .end_bullet2 
.destr_bullet2:
        ld a, 0 
        ld [hl], a 
        dec hl 
        ld [hl], a 
.end_bullet2:

        ld hl, firstBulletX+8
        ld a, [hl] 
        add a, 4 
        cp a, 200 
        jr nc, .destr_bullet3
        ld [hl], a 
        jr .end_bullet3
.destr_bullet3:
        ld a, 0 
        ld [hl], a 
        dec hl 
        ld [hl], a 
.end_bullet3:
       
        ; bulletSwapBuffer for intl'd bullets

        ; Check joypad
        ld a, [joypadReg]
        and %00010000       ; right
        call nz, movePlayerRight
        ld a, [joypadReg]
        and %00100000
        call nz, movePlayerLeft
        ld a, [joypadReg]
        and %01000000
        call nz, movePlayerUp
        ld a, [joypadReg]
        and %10000000
        call nz, movePlayerDown
        ld a, [joypadReg]
        and %00000001
        call nz, pressed_A

        jp FrameLoop        ; back to top

;;;;;; END MAIN LOOP ;;;;;;;;;;


; simple draw cloud
DrawCloudTest:
    ld a, 3
    ld [_SCRN0+70], a
    ld [_SCRN0+70+(32*8)-5], a
    inc a 
    ld [_SCRN0+71], a
    ld [_SCRN0+71+(32*8)-5], a
    inc a 
    ld [_SCRN0+72], a
    ld [_SCRN0+72+(32*8)-5], a
    inc a
    ld [_SCRN0+73], a
    ld [_SCRN0+73+(32*8)-5], a
    inc a 
    ld [_SCRN0+74], a
    ld [_SCRN0+74+(32*8)-5], a
    ld a, 3+16
    ld [_SCRN0+70+32], a
    ld [_SCRN0+70+(32*8)-5], a
    inc a 
    ld [_SCRN0+71+32], a
    ld [_SCRN0+71+(32*8)-5], a
    inc a 
    ld [_SCRN0+72+32], a
    ld [_SCRN0+72+(32*8)-5], a
    inc a 
    ld [_SCRN0+73+32], a
    ld [_SCRN0+73+(32*8)-5], a
    inc a 
    ld [_SCRN0+74+32], a
    ld [_SCRN0+74+(32*8)-5], a
ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PLAYER MOVEMENT ROUTINES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

movePlayerRight:
        ld a, [playerSprite2_x]
        cp 160
        ret z
        inc a
        ld [playerSprite2_x], a
        ld [playerSprite4_x], a
        sub a, 8
        ld [playerSprite1_x], a
        ld [playerSprite3_x], a
    ret

movePlayerLeft:
        ld a, [playerSprite2_x]
        cp a,0
        ret z
        dec a
        ld [playerSprite2_x], a
        ld [playerSprite4_x], a
        sub a, 8
        ld [playerSprite1_x], a
        ld [playerSprite3_x], a
    ret

movePlayerUp:
        ld a, [playerSprite2_y]
        cp 16
        ret z
        dec a
        ld [playerSprite2_y], a
        ld [playerSprite1_y], a
        add a, 8
        ld [playerSprite4_y], a
        ld [playerSprite3_y], a
    ret

movePlayerDown:
        ld a, [playerSprite2_y]
        cp 160
        ret z
        inc a
        ld [playerSprite2_y], a
        ld [playerSprite1_y], a
        add a, 8
        ld [playerSprite4_y], a
        ld [playerSprite3_y], a
    ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BUTTON ROUTINES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pressed_A:
        ; _OAMRAM + (4*20) = bullet 1
pbullet1_y        equ     _OAMRAM+(4*21)
pbullet2_y        equ     _OAMRAM+(4*21)+4
pbullet3_y        equ     _OAMRAM+(4*21)+8

        ld a, [fireDelay]
        cp 0 
        jr nz, .end
        
        ld hl, pbullet1_y
        ld a, [hl]
        cp 16
        jr c, .gobullet          ; if 16 > a, we can use bullet1
        ld hl, pbullet2_y
        ld a, [hl] 
        cp 16 
        jr c, .gobullet 
        ld hl, pbullet3_y

.gobullet:
        ld a, 20
        ld [fireDelay], a
        
        ld a, [playerSprite2_y]
        add a, 5
        ld [hl], a
        ld a, [playerSprite2_x]
        add a, 6
        inc hl
        ld [hl], a
        ld a, 2
        inc hl
        ld [hl], a
        ld a, %00010000
        inc hl
        ld [hl], a
.end:
    ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MOVE ENEMY ROUTINE
;; decreases X for every enemy sprite
;; OAMRAM+20 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SPAWN ENEMY ROUTINE
;; b - enemy type. 1 = squid, 2=kniffish
;; c - enemy x
;; d - enemy y 
;; A - enemy number (1-5)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;bsvar equ _RAM+99

SpawnEnemy_ABCD:
    ld hl, _OAMRAM+16;3        ; < OAM offset-4
.addrLoop:
    ld [$ff80], a 
    ld a, b 
    ld [$ff81], a           ; store num of* in ff80
    ld a, c 
    ld [$ff82], a 
    ld a, [$ff80]

    ld bc, 4 
    add hl, bc 
    dec a 
    jr nz, .addrLoop
    ld a, [$ff81]
    ld b, a 
    ld a, [$ff82]
    ld c, a 

.next:
    ld a, b
    cp 1
    jr z, .drawSquid

.drawSquid:
    ld e, 48 
.setPos:
    ld a, d
    ld [hl+], a ; 0 y
    ld a, c
    ld [hl+], a ; 1 x
    ld a, e
    ld [hl+], a 
    ld a, 0 
    ld [hl+], a 
    ld a, d 
    ld [hl+], a ; 4 
    ld a, c 
    add a, 8 
    ld [hl+], a ; 5
    ld a, e 
    inc a 
    ld e, a 
    ld [hl+], a ; 6
    ld a, 0 
    ld [hl+], a ; 7 , palette
    ld a, d 
    add a, 8 
    ld [hl+], a ; 8 
    ld a, c 
    ld [hl+], a ; 9 
    ld a, e 
    add a,15 
    ld e, a 
    ld [hl+], a 
    ld a, 0 
    ld [hl+], a ;11
    ld a, d 
    add a, 8 
    ld [hl+], a ; 12
    ld a, c 
    add a, 8 
    ld [hl+], a ; 13
    ld a, e 
    inc a 
    ld e, a 
    ld [hl+], a ; 14 
    ld a, 0 
    ld [hl+], a 

    ;skip one
ret


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Read Joypad Routine:

readJoypad:
        ; read cross
        ld a, %00100000
        ld [rP1], a

        ld a, [rP1]
        ld a, [rP1]
        ld a, [rP1]
        ld a, [rP1]

        and $0f     ; bottom 4 bits
        swap a      ; swapped
        ld b, a     ; store in b

        ld a, %00010000     ; read buttons
        ld [rP1], a

        ld a, [rP1]
        ld a, [rP1]
        ld a, [rP1]
        ld a, [rP1]     ; bounce ?

        and $0f
        or b            
        
        cpl     ; compliment
        ld [joypadReg], a

    ret

; If you don't want to worry about the player calls, set up a series of
; rLY=rLYC interrupts, so that every interrupt sets the rLYC register to
; wait for the next player call, and the last interrupt sets rLYC back to
; the first line for looping.
; # rLY  CALL                   CPU usage (LCD lines)
; 1 $08  Player_MusicUpdate     1-3
; 2 $10  Player_SampleUpdate    0-1
; 3 $36  Player_SampleUpdate    0-1
; 4 $5d  Player_SampleUpdate    0-1
; 5 $83  Player_SampleUpdate    0-1
;(6 $90  Normal VBlank interrupt routines here if needed)

StopExample:
        ld      a,MusicBank             ; Switch to MusicBank
        ld      [rROMB0],a
        call    Player_MusicStop        ; Stops reading note data and cuts
                                        ; all music notes currently playing
        ret

WaitLCDLine:
        ld      a,[rLY]
        cp      c
        jr      nz,WaitLCDLine          
        ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Turn off LCD
;; and wait for confirmation

LCD_Off:
    ld a,[rLCDC]    ; register LCD c
    rlca            ; roll a left, b7>c
    ret nc          ; ret if c off
.VBlank_loop
    ld a,[rLY]      ; ff44, lcd y
    cp 145          ; at bottom?
    jr nz, .VBlank_loop ; wait
    ld a,[rLCDC]    ; load lcd reg
    res 7,a         ; reset bit 7 (enabled bit) in a to 0
    ld [rLCDC],a    ; return a to rLCDC
    ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Interrupt vector info:
draw:
stat:
timer:
serial:
joypad:
    reti


;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DATA BLOCKS
;;;;;;;;;;;;;;;;;;;;;;;;;;;

TileData:
TileChar:
INCLUDE "gbjamtiles8000.asm"
INCLUDE "gbjamtiles9000.asm"
EndTileChar:
;BGChar:
;INCLUDE
;EndBGChar:
GraphicsBuffers:
;bulletSwapBuffer:
;    ds 80

; ASSEMBLER OUTPUT
MAINCODEEND:
SECTION "Music",ROMX[$4000],BANK[MusicBank]
MUSICSTART:
    INCBIN "carillon.bin"              ; player code and music data
MUSICEND:
SECTION "Reserved",WRAM0[$c7c0]
MUSICRESERVED:
    ds      $30                     ; $c7c0 - $c7ef for player variables
MUSICRESERVEDEND:

PRINTT "Main code size: "
PRINTV MAINCODEEND-MAINCODESTART
PRINTT "\nFree space in bank 0: "
PRINTV $3fff - $150 - (MAINCODEEND-MAINCODESTART)
PRINTT "\n ** Bank 1 full of music! ** "
PRINTT "\n"
PRINTT "(Size of charset:)"
PRINTV EndTileChar-TileChar

